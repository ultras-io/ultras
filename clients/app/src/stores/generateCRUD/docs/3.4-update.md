# State Key: `update`:

The `update` state key has following type:

```typescript
interface StateFieldUpdateInterface<TFieldValue = string> {
  isValid: boolean;
  valueOriginal: TFieldValue | null;
  valueToSave: TFieldValue | null;
  errors: Array<string>;
}
interface StateDataUpdateInterface<TFieldValue = string> {
  [key: string]: StateFieldUpdateInterface<TFieldValue>;
}

interface UpdateStateDataInterface<TData> {
  status: StatusType;
  resourceId: null | ResourceIdentifier;
  error: null | Error;
  data: null | StateDataUpdateInterface;
  valid: boolean;
}
```

CRUD generator excepting following API response:

```typescript
interface ApiSingleResponseInterface<TModel> {
  data: TModel;
  meta: {};
}
```

When `update` key provided, the system will add `update` state, `updateData` and `setUpdateFieldValue` methods to your store, but it requires `updateData` method in generator options, also you can pass `scheme` and `beforeSend` as optional parameters to CRUD generator:

- `scheme` is a object with model keys but with optional pre-processors and parameters.
- `beforeSend` is a function that will be called once before sending data to backend.

Scheme interface:

```typescript
interface SchemeFieldInterface<TFieldValue = string> {
  initialValue?: TFieldValue | null;
  processValue?(valueOriginal: TFieldValue | null): TFieldValue;
  validate?(
    valueOriginal: TFieldValue | null,
    valueToSave: TFieldValue | null
  ): Array<string>;
}

type SchemeInterface<T> = {
  [TKey in keyof T]: SchemeFieldInterface<T[TKey]>;
}
```

- `initialValue` is a field that will be applied when state created
- `processValue` is a callback that will be called after value change and returned value
  will de set to `valueToSave`.
- `validate` is a callback that will be called after value change and `processValue`.

Example:

```typescript
// ...

interface DataSchemeInterface {
  name: string;
  description: string;
}

const scheme: SchemeInterface<DataSchemeInterface> = {
  name: {
    processValue: (valueOriginal: string) => {
      return valueOriginal.trim();
    },
    validate: (valueOriginal: string, valueToSave: string) => {
      return !!valueOriginal;
    },
  },

  description: {
    initialValue: 'The most fan club.',
    validate: (valueOriginal: string, valueToSave: string) => {
      return !!valueOriginal;
    },
  },
};

const store = generateCRUD<FanClubViewModel, TFilter, TKey>({
  keys: ['update'],
  scheme: scheme,

  updateData: (
    resourceId: null | ResourceIdentifier,
    data: Partial<FanClubViewModel>
  ) => {
    return sdk.updateFanClub(resourceId, data);
  },
});
```

Your component will look like this:

```tsx
import React, { useCallback } from 'react';
// ...

function App() {
  const { update } = store.useSelector('update');

  const setValue = useCallback((key: string, value: string) => {
    store.setUpdateFieldValue(key, value);
  }, []);

  const onSubmit = useCallback(() => {
    store.updateData();
  }, []);

  return (
    <div>
      {update.status == 'loading' ? (
        <LoadingView />
      ) : (
        <FanClubForm
          setValue={setValue}
          onSubmit={onSubmit}
          error={update.error}
        />
      )}
    </div>
  );
}
```
